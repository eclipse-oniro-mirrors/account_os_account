/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.account.osAccount", "osAccount")

use ohos.account.distributedAccount as distributedAccount;

@!sts_inject_into_module("import { BusinessError } from '@ohos.base';")
@!sts_inject_into_module("import { RecordData } from '@ohos.base';")

@!sts_inject("""
static { loadLibrary("os_account_taihe_native.z") }
""")

@overload("getAccountManager")
function GetAccountManager(): AccountManager;

interface AccountManager {
    @gen_async("isMainOsAccount")
    @gen_promise("isMainOsAccount")
    IsMainOsAccountSync():bool;

    @gen_async("getOsAccountProfilePhoto")
    @gen_promise("getOsAccountProfilePhoto")
    GetOsAccountProfilePhotoSync(localId: i32): String;

    @gen_promise("getOsAccountType")
    @gen_async("getOsAccountType")
    GetOsAccountTypeSync(): OsAccountType;
    @gen_promise("getOsAccountType")
    GetOsAccountTypeWithIdSync(localId: i32): OsAccountType;

    on(type: String,name: String, callback: (id:i32) => void): void;

    off(type: String,name: String, callback: Optional<(id:i32) => void>): void;

    @on_off("switching")
    OnSwitching(callback: (data:OsAccountSwitchEventData) => void): void;
    @on_off("switched")
    OnSwitched(callback: (data:OsAccountSwitchEventData) => void): void;

    @on_off("switching")
    OffSwitching(callback: Optional<(data:OsAccountSwitchEventData) => void>): void;
    @on_off("switched")
    OffSwitched(callback: Optional<(data:OsAccountSwitchEventData) => void>): void;

    @gen_async("activateOsAccount")
    @gen_promise("activateOsAccount")
    ActivateOsAccountSync(localId: i32): void;

    @gen_async("createOsAccount")
    CreateOsAccountSync(localName: String, type: OsAccountType): OsAccountInfo;

    @gen_promise("createOsAccount")
    CreateOsAccountWithOptionSync(localName: String, type: OsAccountType, options: Optional<CreateOsAccountOptions>): OsAccountInfo;

    @gen_promise("deactivateOsAccount")
    DeactivateOsAccountSync(localId: i32): void;

    @gen_async("getActivatedOsAccountLocalIds")
    @gen_promise("getActivatedOsAccountLocalIds")
    GetActivatedOsAccountLocalIdsSync(): Array<i32>;

    @gen_promise("queryOsAccount")
    QueryOsAccountSync(): OsAccountInfo;

    @gen_promise("getForegroundOsAccountLocalId")
    GetForegroundOsAccountLocalIdSync(): i32;

    @gen_async("getOsAccountLocalId")
    @gen_promise("getOsAccountLocalId")
    GetOsAccountLocalIdSync(): i32;

    @gen_async("getOsAccountLocalIdForUid")
    @gen_promise("getOsAccountLocalIdForUid")
    GetOsAccountLocalIdForUidSyncTaihe(uid: i32): i32;

    @gen_promise("isOsAccountUnlocked")
    IsOsAccountUnlockedSync(): bool;

    @gen_promise("isOsAccountUnlocked")
    IsOsAccountUnlockedById(localId: i32): bool;

    @gen_async("queryAllCreatedOsAccounts")
    @gen_promise("queryAllCreatedOsAccounts")
    QueryAllCreatedOsAccountsSync(): Array<OsAccountInfo>;

    @gen_promise("queryMaxLoggedInOsAccountNumber")
    QueryMaxLoggedInOsAccountNumberSync(): i32;

    @gen_async("queryOsAccountById")
    @gen_promise("queryOsAccountById")
    QueryOsAccountByIdSync(localId: i32): OsAccountInfo;

    @gen_promise("setOsAccountProfilePhoto")
    @gen_async("setOsAccountProfilePhoto")
    SetOsAccountProfilePhotoSync(localId: i32, photo: String);

    @gen_promise("getOsAccountLocalIdForSerialNumber")
    @gen_async("getOsAccountLocalIdForSerialNumber")
    GetOsAccountLocalIdForSerialNumberSync(serialNumber: i64): i32;

    @gen_promise("getSerialNumberForOsAccountLocalId")
    @gen_async("getSerialNumberForOsAccountLocalId")
    GetSerialNumberForOsAccountLocalIdSync(localId: i32): i32;

    @gen_promise("getBundleIdForUid")
    @gen_async("getBundleIdForUid")
    GetBundleIdForUidWithIdSync(uid: i32): i32;

    @overload("getBundleIdForUidSync")
    GetBundleIdForUidSyncTaihe(uid: i32): i32;

    @gen_promise("getOsAccountConstraintSourceTypes")
    @gen_async("getOsAccountConstraintSourceTypes")
    GetOsAccountConstraintSourceTypesSync(localId: i32, constraint: String): Array<ConstraintSourceTypeInfo>;

    @gen_async("checkMultiOsAccountEnabled")
    @gen_promise("checkMultiOsAccountEnabled")
    CheckMultiOsAccountEnabledSync(): bool;

    @gen_async("removeOsAccount")
    @gen_promise("removeOsAccount")
    RemoveOsAccountSync(localId: i32);

    @gen_async("setOsAccountName")
    @gen_promise("setOsAccountName")
    SetOsAccountNameSync(localId: i32, localName: String);

    @gen_promise("isOsAccountActivated")
    IsOsAccountActivatedSync(localId: i32): bool;

    @gen_promise("isOsAccountConstraintEnabled")
    IsOsAccountConstraintEnabledSync(constraint: String): bool;

    @gen_promise("isOsAccountConstraintEnabled")
    IsOsAccountConstraintEnabledWithId(localId: i32, constraint: String): bool;

    @gen_async("checkOsAccountTestable")
    @gen_promise("checkOsAccountTestable")
    CheckOsAccountTestableSync(): bool;

    @gen_async("setOsAccountConstraints")
    @gen_promise("setOsAccountConstraints")
    SetOsAccountConstraintsSync(localId: i32, constraints: Array<String>, enable: bool);

    @gen_promise("getOsAccountName")
    GetOsAccountNameSync(): String;

    @gen_async("getOsAccountCount")
    @gen_promise("getOsAccountCount")
    GetOsAccountCountSync():u32;

    @overload("getOsAccountLocalIdForUidSync")
    GetOsAccountLocalIdForUidSyncOverload(uid: i32): i32;

    @gen_async("getOsAccountLocalIdForDomain")
    @gen_promise("getOsAccountLocalIdForDomain")
    GetOsAccountLocalIdForDomainSync(domainInfo: DomainAccountInfo): i32;

    @gen_async("queryMaxOsAccountNumber")
    @gen_promise("queryMaxOsAccountNumber")
    QueryMaxOsAccountNumberSync(): u32;

    @gen_promise("getEnabledOsAccountConstraints")
    GetEnabledOsAccountConstraintsSync(localId: i32): Array<String>;
    @gen_async("createOsAccountForDomain")
    CreateOsAccountForDomainSync(type: OsAccountType, domainInfo: DomainAccountInfo): OsAccountInfo;

    @gen_promise("createOsAccountForDomain")
    CreateOsAccountForDomainWithOpts(type: OsAccountType, domainInfo: DomainAccountInfo,
        options: Optional<CreateOsAccountForDomainOptions>): OsAccountInfo;

    @gen_promise("getOsAccountDomainInfo")
    GetOsAccountDomainInfoSync(localId: i32): DomainAccountInfo;

    @gen_async("queryDistributedVirtualDeviceId")
    @gen_promise("queryDistributedVirtualDeviceId")
    QueryDistributedVirtualDeviceIdSync(): String;
}

@class
interface UserIdentityManager {
    @gen_async("openSession")
    OpenSession(): @typedarray Array<u8>;

    @gen_promise("openSession")
    OpenSessionPromise(accountId:Optional<i32>): @typedarray Array<u8>;

    @overload("closeSession")
    CloseSession(accountId: Optional<i32>): void;

    @gen_async("getAuthInfo")
    @gen_promise("getAuthInfo")
    GetAuthInfoType(authType: AuthType): Array<EnrolledCredInfo>;

    @gen_promise("getAuthInfo")
    GetAuthInfoWithOptionsSync(options: Optional<GetAuthInfoOptions>): Array<EnrolledCredInfo>;

    @overload("addCredential")
    AddCredential(info: CredentialInfo, callback: IIdmCallback): void;

    @overload("updateCredential")
    UpdateCredential(credentialInfo: CredentialInfo, callback: IIdmCallback): void;

    @overload("delUser")
    DelUser(token: @typedarray Array<u8>, callback: IIdmCallback);

    @overload("cancel")
    CancelWithChallenge(challenge: @typedarray Array<u8>): void;

    @overload("delCred")
    DelCred(credentialId: @typedarray Array<u8>, token: @typedarray Array<u8>, callback: IIdmCallback);

    @gen_promise("getEnrolledId")
    GetEnrolledIdSync(authType: AuthType, accountId: Optional<i32>): @typedarray Array<u8>;
}

enum AuthType : i32 {
    INVALID = 0,
    PIN = 1,
    FACE = 2,
    FINGERPRINT = 4,
    RECOVERY_KEY = 8,
    PRIVATE_PIN = 16,
    DOMAIN = 1024
}

enum AuthSubType : i32 {
    INVALID = 0,
    PIN_SIX = 10000,
    PIN_NUMBER = 10001,
    PIN_MIXED = 10002,
    PIN_FOUR = 10003,
    PIN_PATTERN = 10004,
    PIN_QUESTION = 10005,
    FACE_2D = 20000,
    FACE_3D = 20001,
    FINGERPRINT_CAPACITIVE = 30000,
    FINGERPRINT_OPTICAL = 30001,
    FINGERPRINT_ULTRASONIC = 30002,
    DOMAIN_MIXED = 10240001
}

struct CredentialInfo {
    credType: AuthType;
    credSubType: AuthSubType;
    token: @typedarray Array<u8>;
    accountId: Optional<i32>;
}

struct RequestResult {
    credentialId: Optional<@typedarray Array<u8>>;
}

struct IIdmCallback {
    onResult: (result: i32, extraInfo: RequestResult) => void;
    onAcquireInfo: Optional<(module: i32, acquire: u32, extraInfo: @typedarray Array<u8>)=>void>;
}

enum OsAccountType : u32 {
    ADMIN = 0,
    NORMAL = 1,
    GUEST = 2,
    PRIVATE = 1024
}

struct DomainAccountInfo {
    domain: String;
    accountName: String;
    accountId: Optional<String>;
    isAuthenticated: Optional<bool>;
    serverConfigId: Optional<String>;
}

struct OsAccountInfo {
    localId: i32;
    localName: String;
    shortName: Optional<String>;
    type: OsAccountType;
    constraints: Array<String>;
    isUnlocked: bool;
    photo: String;
    createTime: i64;
    lastLoginTime: i64;
    serialNumber: i64;
    isActivated: bool;
    isLoggedIn: Optional<bool>;
    isCreateCompleted: bool;
    distributedInfo: distributedAccount.DistributedInfo;
    domainInfo: DomainAccountInfo;
}

enum FingerprintTips : u8 {
    FINGERPRINT_TIP_GOOD = 0,
    FINGERPRINT_TIP_IMAGER_DIRTY = 1,
    FINGERPRINT_TIP_INSUFFICIENT = 2,
    FINGERPRINT_TIP_PARTIAL = 3,
    FINGERPRINT_TIP_TOO_FAST = 4,
    FINGERPRINT_TIP_TOO_SLOW = 5,
    FINGERPRINT_TIP_FINGER_DOWN = 6,
    FINGERPRINT_TIP_FINGER_UP = 7
}

enum ResultCode : u8 {
    SUCCESS = 0,
    FAIL = 1,
    GENERAL_ERROR = 2,
    CANCELED = 3,
    TIMEOUT = 4,
    TYPE_NOT_SUPPORT = 5,
    TRUST_LEVEL_NOT_SUPPORT = 6,
    BUSY = 7,
    INVALID_PARAMETERS = 8,
    LOCKED = 9,
    NOT_ENROLLED = 10
}

enum GetPropertyType : u32 {
    AUTH_SUB_TYPE = 1,
    REMAIN_TIMES = 2,
    FREEZING_TIME = 3,
    ENROLLMENT_PROGRESS = 4,
    SENSOR_INFO = 5,
    NEXT_PHASE_FREEZING_TIME = 6
}

struct GetPropertyRequest {
    authType: AuthType;
    keys: Array<GetPropertyType>;
    accountId: Optional<i32>;
}

struct OsAccountSwitchEventData {
    fromAccountId: i32;
    toAccountId: i32;
}

struct GetInputDataOptions {
    challenge: Optional<@typedarray Array<u8>>;
}

struct CreateOsAccountOptions {
    shortName: String;
}

struct GetAuthInfoOptions {
    authType: Optional<AuthType>;
    accountId: Optional<i32>;
}

struct EnrolledCredInfo {
    credentialId: @typedarray Array<u8>;
    authType: AuthType;
    authSubType: AuthSubType;
    templateId: @typedarray Array<u8>;
}

union OptionalError {
    error: @sts_type("BusinessError") Opaque;
    @null nValue;
}

union DomainAccountInfoData {
    data: DomainAccountInfo;
    @undefined uValue;
}

union AuthStatusInfoData {
    data: AuthStatusInfo;
    @undefined uValue;
}

union BoolData {
    data: bool;
    @undefined uValue;
}

union ArrayData {
    data: @typedarray Array<u8>;
    @undefined uValue;
}

struct DomainPlugin {
    auth: (domainAccountInfo: DomainAccountInfo, credential: @typedarray Array<u8>, callback: IUserAuthCallback) => void;
    authWithPopup: (domainAccountInfo: DomainAccountInfo, callback: IUserAuthCallback) => void;
    authWithToken: (domainAccountInfo: DomainAccountInfo, token: @typedarray Array<u8>, callback: IUserAuthCallback) => void;
    getAccountInfo: (options: GetDomainAccountInfoPluginOptions, callback: (err: OptionalError, data: DomainAccountInfoData) => void) => void;
    getAuthStatusInfo: (domainAccountInfo: DomainAccountInfo, callback: (err: OptionalError, data: AuthStatusInfoData) => void) => void;
    bindAccount: (domainAccountInfo: DomainAccountInfo, localId: i32, callback: (err: OptionalError) => void) => void;
    unbindAccount: (domainAccountInfo: DomainAccountInfo, callback: (err: OptionalError) => void) => void;
    isAccountTokenValid: (domainAccountInfo: DomainAccountInfo, token: @typedarray Array<u8>, callback: (err: OptionalError, data: BoolData) => void) => void;
    getAccessToken: (options: GetDomainAccessTokenOptions, callback: (err: OptionalError, data: ArrayData) => void) => void;
}

@class
interface DomainAccountManager {}

@class
interface DomainServerConfigManager {}

@static("DomainAccountManager")
@gen_promise("isAuthenticationExpired")
function IsAuthenticationExpiredSync(domainAccountInfo: DomainAccountInfo): bool;

@static("DomainAccountManager")
@overload("registerPlugin")
function RegisterPlugin(plugin: DomainPlugin): void;

@static("DomainAccountManager")
@overload("unregisterPlugin")
function UnregisterPlugin(): void;

@static("DomainAccountManager")
@overload("auth")
function Auth(domainAccountInfo: DomainAccountInfo, credential: @typedarray Array<u8>, callback: IUserAuthCallback): void;

@static("DomainAccountManager")
@overload("authWithPopup")
function AuthWithPopup(callback: IUserAuthCallback): void;

@static("DomainAccountManager")
@overload("authWithPopup")
function AuthWithPopupWithId(localId: i32, callback: IUserAuthCallback): void;

@static("DomainAccountManager")
@gen_async("hasAccount")
@gen_promise("hasAccount")
function HasAccountSync(domainAccountInfo: DomainAccountInfo): bool;

@static("DomainAccountManager")
@gen_async("updateAccountToken")
@gen_promise("updateAccountToken")
function UpdateAccountTokenSync(domainAccountInfo: DomainAccountInfo, token: @typedarray Array<u8>);

@static("DomainAccountManager")
@gen_async("getAccessToken")
@gen_promise("getAccessToken")
function GetAccessTokenSync(businessParams: @sts_type("RecordData")Opaque): @typedarray Array<u8>;

@static("DomainAccountManager")
@gen_async("getAccountInfo")
@gen_promise("getAccountInfo")
function GetAccountInfoSync(options: GetDomainAccountInfoOptions): DomainAccountInfo;

@static("DomainAccountManager")
@gen_promise("updateAccountInfo")
function UpdateAccountInfoSync(oldAccountInfo: DomainAccountInfo, newAccountInfo: DomainAccountInfo);

@static("DomainServerConfigManager")
@gen_promise("addServerConfig")
function AddServerConfigSync(parameters: @sts_type("RecordData")Opaque): DomainServerConfig;

@static("DomainServerConfigManager")
@gen_promise("removeServerConfig")
function RemoveServerConfigSync(configId: String);

@static("DomainServerConfigManager")
@gen_promise("updateServerConfig")
function UpdateServerConfigSync(configId: String, parameters: @sts_type("RecordData")Opaque):DomainServerConfig;

@static("DomainServerConfigManager")
@gen_promise("getServerConfig")
function GetServerConfigSync(configId: String): DomainServerConfig;

@static("DomainServerConfigManager")
@gen_promise("getAllServerConfigs")
function GetAllServerConfigsSync(): Array<DomainServerConfig>;

@static("DomainServerConfigManager")
@gen_promise("getAccountServerConfig")
function GetAccountServerConfigSync(domainAccountInfo: DomainAccountInfo): DomainServerConfig;

struct AuthResult {
    token: Optional<@typedarray Array<u8>>;
    remainTimes: Optional<i32>;
    freezingTime: Optional<i32>;
    nextPhaseFreezingTime: Optional<i32>;
    credentialId: Optional<@typedarray Array<u8>>;
    accountId: Optional<i32>;
    pinValidityPeriod: Optional<i64>;
}

enum AuthTrustLevel: i32 {
    ATL1 = 10000,
    ATL2 = 20000,
    ATL3 = 30000,
    ATL4 = 40000
}

enum AuthIntent: i32 {
    DEFAULT = 0,
    UNLOCK = 1,
    SILENT_AUTH = 2,
    QUESTION_AUTH = 3,
}

enum SetPropertyType: i32 {
    INIT_ALGORITHM = 1
}

struct SetPropertyRequest {
    authType: AuthType;
    key: SetPropertyType;
    setInfo: @typedarray Array<u8>;
}

struct RemoteAuthOptions {
    verifierNetworkId: Optional<String>;
    collectorNetworkId: Optional<String>;
    collectorTokenId: Optional<i32>;
}

struct AuthOptions {
    accountId: Optional<i32>;
    authIntent: Optional<AuthIntent>;
    remoteAuthOptions: Optional<RemoteAuthOptions>;
}

struct ExecutorProperty {
    result: i32;
    authSubType: AuthSubType;
    remainTimes: Optional<i32>;
    freezingTime: Optional<i32>;
    nextPhaseFreezingTime: Optional<i32>;
    enrollmentProgress: Optional<String>;
    sensorInfo: Optional<String>;
}

struct IUserAuthCallback {
    onResult: (result: i32, extraInfo: AuthResult) => void;
    onAcquireInfo: Optional<(module: i32, acquire: i32, extraInfo: @typedarray Array<u8>)=>void>;
}

struct IInputer {
    onGetData: (authSubType: AuthSubType, callback: IInputData, options: GetInputDataOptions) => void;
}

interface IInputData {
    GetSpecificImplPtr (): i64;
    GetIInputDataPtr (): i64;
    OnSetData(authSubType: AuthSubType, data: @typedarray Array<u8>): void;
}

function createIInputData(ptr: i64): IInputData;
function getPtrByIInputData(data: IInputData): i64;

@class
interface UserAuth {
    @overload("auth")
    AuthSync(challenge: @typedarray Array<u8>, authType: AuthType,
        authTrustLevel: AuthTrustLevel, callback: IUserAuthCallback): @typedarray Array<u8>;

    @overload("auth")
    AuthWithOptSync(challenge: @typedarray Array<u8>, authType: AuthType,
        authTrustLevel: AuthTrustLevel, options: AuthOptions, callback: IUserAuthCallback): @typedarray Array<u8>;

    @overload("authUser")
    AuthUser(userId: i32, challenge: @typedarray Array<u8>, authType: AuthType,
        authTrustLevel: AuthTrustLevel, callback: IUserAuthCallback): @typedarray Array<u8>;

    @overload("cancelAuth")
    CancelAuth(contextID: @typedarray Array<u8>): void;

    @gen_async("getProperty")
    @gen_promise("getProperty")
    GetPropertySync(request: GetPropertyRequest): ExecutorProperty;

    @gen_async("setProperty")
    @gen_promise("setProperty")
    SetPropertySync(request: SetPropertyRequest): void;

    @overload("getVersion")
    GetVersionSync(): i32;

    @overload("getAvailableStatus")
    GetAvailableStatusSync(authType: AuthType, authTrustLevel: AuthTrustLevel): i32;

    @gen_promise("getPropertyByCredentialId")
    GetPropertyByCredentialIdSync(credentialId: @typedarray Array<u8>, keys: Array<GetPropertyType>): ExecutorProperty;

    @gen_promise("prepareRemoteAuth")
    PrepareRemoteAuthSync(remoteNetworkId: String): void;
}

@class
interface PINAuth {
    @overload("registerInputer")
    RegisterInputer(inputer: IInputer): void;

    @overload("unregisterInputer")
    UnregisterInputer(): void;
}

@class
interface InputerManager {
}

@static("InputerManager")
function registerInputer(authType: AuthType, inputer: IInputer): void;
@static("InputerManager")
function unregisterInputer(authType: AuthType): void;

@ctor("UserIdentityManager")
function CreateUserIdentityManager(): UserIdentityManager;

@ctor("UserAuth")
function CreateUserAuth(): UserAuth;

@ctor("PINAuth")
function CreatePINAuth(): PINAuth;

struct AuthStatusInfo {
    remainTimes: i32;
    freezingTime: i32;
}

struct GetDomainAccessTokenOptions {
    domainAccountInfo: DomainAccountInfo;
    domainAccountToken: @typedarray Array<u8>;
    businessParams: @sts_type("RecordData")Opaque;
    callerUid: i32;
}

struct GetDomainAccountInfoOptions {
    accountName: String;
    domain: Optional<String>;
    serverConfigId: Optional<String>;
}

@class
struct GetDomainAccountInfoPluginOptions {
    @extends options: GetDomainAccountInfoOptions;
    callerUid: i32;
}

struct DomainServerConfig {
    parameters: @sts_type("RecordData")Opaque;
    id: String;
    domain: String;
}

enum FaceTipsCode : i32 {
    FACE_AUTH_TIP_TOO_BRIGHT = 1,
    FACE_AUTH_TIP_TOO_DARK = 2,
    FACE_AUTH_TIP_TOO_CLOSE = 3,
    FACE_AUTH_TIP_TOO_FAR = 4,
    FACE_AUTH_TIP_TOO_HIGH = 5,
    FACE_AUTH_TIP_TOO_LOW = 6,
    FACE_AUTH_TIP_TOO_RIGHT = 7,
    FACE_AUTH_TIP_TOO_LEFT = 8,
    FACE_AUTH_TIP_TOO_MUCH_MOTION = 9,
    FACE_AUTH_TIP_POOR_GAZE = 10,
    FACE_AUTH_TIP_NOT_DETECTED = 11
}

enum ConstraintSourceType : i32 {
    CONSTRAINT_NOT_EXIST = 0,
    CONSTRAINT_TYPE_BASE = 1,
    CONSTRAINT_TYPE_DEVICE_OWNER = 2,
    CONSTRAINT_TYPE_PROFILE_OWNER = 3
}

enum Module : i32 {
    FACE_AUTH = 1
}

struct ConstraintSourceTypeInfo {
    localId: i32;
    type: ConstraintSourceType;
}

@class
struct CreateOsAccountForDomainOptions {
    @extends options: CreateOsAccountOptions;
}
